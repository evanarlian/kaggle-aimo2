import asyncio
import json
import os
import time
from collections import Counter
from pathlib import Path
from typing import Literal, Optional

import polars as pl
from openai import AsyncOpenAI
from pydantic import BaseModel
from transformers import AutoTokenizer, PreTrainedTokenizer

import kaggle_evaluation.aimo_2_inference_server
from aimo2.parser.latex import MyLatexParser, extract_boxed_text
from aimo2.timer import Timer
from aimo2.utils import is_kaggle, wib_now


class Config(BaseModel):
    n_parallel: int  # launch n parallel calls to vllm per question
    n_first: int  # consider only the top n_first, and discard the slowest ones
    model: str  # single model to call
    grammar_dir: Path  # path to modified latex grammar
    num_questions: int  # number of questions for timing purposes
    hours: float  # total competition hours
    exp_path: Path  # experiment folder
    source_csv: str  # the test csv path for kaggle inference server


class ConversationResult(BaseModel):
    """Core inference result"""

    boxed_answer: Optional[str]  # raw answer generated by llm
    parsed_answer: Optional[int]  # parsed answer using sympy after modulus
    history: list[dict[Literal["role", "content"], str]]
    temperature: float
    top_p: float
    min_p: float


class ConversationReport(ConversationResult):
    """Wraps core and adding admin stuffs"""

    q_id: str
    gt_answer: Optional[int]
    elapsed: float


async def conversation(
    q_text: str,
    q_id: str,
    client: AsyncOpenAI,
    tokenizer: PreTrainedTokenizer,
    parser: MyLatexParser,
    cfg: Config,
) -> ConversationResult:
    """Core conversation logic"""
    # 0. randomizer
    # TODO make random later? we need speed tho
    temperature = 1.0
    top_p = 0.9
    min_p = 0.1
    # 1. get answer initial answer
    history: list = [{"role": "user", "content": q_text}]
    completion1 = await client.chat.completions.create(
        model=cfg.model,
        messages=history,
        temperature=temperature,
        top_p=top_p,
        stop=["</think>"],  # don't waste time on repeating what the model knows
        extra_body={"min_p": min_p},
    )
    assert completion1.choices[0].message.content is not None
    reply1 = completion1.choices[0].message.content
    history.append({"role": "assistant", "content": reply1})
    # 2. force the model to output in the right format if not exist
    box_content1 = extract_boxed_text(reply1)
    print(f"[{q_id}] box_content1: {box_content1}")
    if box_content1 is None:
        # try to fix it once
        history[-1]["content"] = (
            history[-1]["content"].replace("</think>", "<think2>")
            + "\n\n**Final Answer:**\n\\[\n\\boxed{"
        )
        raw = tokenizer.apply_chat_template(
            history,
            tokenize=False,
            add_generation_prompt=False,
            continue_final_message=True,
        ).replace("<think2>", "</think>")  # type: ignore
        completion2 = await client.completions.create(
            model=cfg.model,
            prompt=raw,
            temperature=temperature,
            top_p=top_p,
            extra_body={"min_p": min_p},
        )
        reply2 = history[-1]["content"] + completion2.choices[0].text
        history[-1]["content"] = reply2
        box_content2 = extract_boxed_text(reply2)
        print(f"[{q_id}] box_content2: {box_content2}")
        if box_content2 is None:
            # still no box after this, just bail
            return ConversationResult(
                boxed_answer=None,
                parsed_answer=None,
                history=history,
                temperature=temperature,
                top_p=top_p,
                min_p=min_p,
            )
        box_content1 = box_content2
    # 3. extract
    predicted_num = parser.latex_to_int_modded(box_content1)
    print(f"[{q_id}] predicted_num: {predicted_num}")
    if predicted_num is None:
        # unparsable number here
        return ConversationResult(
            boxed_answer=box_content1,
            parsed_answer=None,
            history=history,
            temperature=temperature,
            top_p=top_p,
            min_p=min_p,
        )
    print(f"[{q_id}] convo done!")
    return ConversationResult(
        boxed_answer=box_content1,
        parsed_answer=predicted_num % 1000,
        history=history,
        temperature=temperature,
        top_p=top_p,
        min_p=min_p,
    )


async def worker(
    q_text: str,
    q_id: str,
    gt_answer: Optional[int],
    voting: Counter,
    client: AsyncOpenAI,
    tokenizer: PreTrainedTokenizer,
    parser: MyLatexParser,
    cfg: Config,
) -> ConversationReport:
    """Wrapper for core, adding admin stuffs and doing the actual voting"""
    t0 = time.perf_counter()
    convo = await conversation(q_text, q_id, client, tokenizer, parser, cfg)
    elapsed = time.perf_counter() - t0
    if convo.parsed_answer is not None:
        voting[convo.parsed_answer] += 1
    return ConversationReport(
        **convo.model_dump(),
        q_id=q_id,
        gt_answer=gt_answer,
        elapsed=elapsed,
    )


async def solve_one(
    q_text: str,
    q_id: str,
    gt_answer: Optional[int],
    client: AsyncOpenAI,
    tokenizer: PreTrainedTokenizer,
    parser: MyLatexParser,
    timer: Timer,
    cfg: Config,
) -> int:
    """Manages workers (parallel calls to vllm)"""
    allowed_time = timer.start_question()
    print(f"[{q_id}] allowed time: {allowed_time}")
    voting = Counter()
    print(f"[{q_id}] creating {cfg.n_parallel} workers")
    worker_tasks = [
        asyncio.create_task(
            worker(q_text, q_id, gt_answer, voting, client, tokenizer, parser, cfg)
        )
        for _ in range(cfg.n_parallel)
    ]
    # TODO if i want to stop early i can use as_completed instead for top 75% logic
    done, pending = await asyncio.wait(worker_tasks, timeout=allowed_time)
    # print(len(done), len(pending))
    # throw away pendings
    for p in pending:
        p.cancel()
    await asyncio.gather(*pending, return_exceptions=True)
    # collect successful worker
    convo_reports = [
        d
        for d in await asyncio.gather(*done, return_exceptions=True)
        if isinstance(d, ConversationReport)
    ]
    # save to json
    cfg.exp_path.parent.mkdir(parents=True, exist_ok=True)
    if cfg.exp_path.exists():
        with open(cfg.exp_path, "r") as f:
            existing = json.load(f)
    else:
        existing = []
    existing += [c.model_dump() for c in convo_reports]
    with open(cfg.exp_path, "w") as f:
        json.dump(existing, f, indent=4)
    print(f"[{q_id}] convos added to {cfg.exp_path}")
    try:
        answer, n_votes = voting.most_common(1)[0]
    except IndexError:
        print(f"[{q_id}] there are no votes at all, convos might be too long")
        answer = 0
    # complete!
    timer.finish_question()
    return answer


########################################################################################

if is_kaggle():
    cfg = Config(
        n_parallel=32,
        n_first=24,
        model="/kaggle/input/deepseek-r1/transformers/deepseek-r1-distill-qwen-7b-awq-casperhansen/1",
        grammar_dir=Path("TODO"),
        num_questions=50,
        hours=5,
        exp_path=Path("experiments") / f"exp_{wib_now()}.json",
        source_csv="/kaggle/input/ai-mathematical-olympiad-progress-prize-2/test.csv",
    )
else:
    cfg = Config(
        n_parallel=32,
        n_first=24,
        model="casperhansen/deepseek-r1-distill-qwen-1.5b-awq",
        grammar_dir=Path("aimo2/parser"),
        num_questions=1,
        hours=1 / 10,
        exp_path=Path("experiments") / f"exp_{wib_now()}.json",
        source_csv="data/reference2.csv",
    )
timer = Timer(
    n_questions=cfg.num_questions,
    time_limit=cfg.hours * 60 * 60 * 0.95,  # give a bit of a headroom
)
tokenizer = AutoTokenizer.from_pretrained(cfg.model)
parser = MyLatexParser(cfg.grammar_dir, mod=1000, timeout=2.0)
client = AsyncOpenAI(base_url="http://localhost:8000/v1", api_key="-")


# Replace this function with your inference code.
# The function should return a single integer between 0 and 999, inclusive.
# Each prediction (except the very first) must be returned within 30 minutes of the question being provided.
def predict(
    id_: pl.DataFrame, question: pl.DataFrame, answer: Optional[int] = None
) -> pl.DataFrame:
    id_ = id_.item(0)
    q_text = question.item(0)
    prediction = asyncio.run(
        solve_one(q_text, str(id_), answer, client, tokenizer, timer, cfg)  # type: ignore
    )
    return pl.DataFrame({"id": id_, "answer": prediction})


def main():
    inference_server = kaggle_evaluation.aimo_2_inference_server.AIMO2InferenceServer(
        predict  # type: ignore
    )
    if os.getenv("KAGGLE_IS_COMPETITION_RERUN"):
        inference_server.serve()
    else:
        inference_server.run_local_gateway((cfg.source_csv,))
        # sanity check
        df = pl.read_parquet("submission.parquet")
        print(df)


if __name__ == "__main__":
    main()
